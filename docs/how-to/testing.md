

# docs/how-to/testing.md


# Testing（CIと同じようにテストして、落ちたら直す）
この文書は **How-to（やり方）** です。  
「なぜこのテストが必要か」は Explanation / ADR 側に寄せます。  
ここでは **“どうやってテストを回して合否を見るか”** だけを扱います。

---

## 0. この文書はいつ使う？
- PRを出す前（最低限ここに書いてあるテストを通す）
- CIが落ちたとき（どこを見て、どう再現するか）
- 受け入れ条件を「実行できる仕様」に寄せたいとき（テストを追加したいとき）

---

## 1. まず「どこが正（source of truth）か」を固定する
### 1.1 正（source of truth）
- **CIで実行される順番**：`.github/workflows/ci.yml`
- **実行コマンドの定義**：`package.json` → `scripts`

DotChain の scripts（例）：
- `pnpm lint`
- `pnpm test`
- `pnpm test:e2e`（Maestro smoke）
※ 型チェックを使う場合は `type-check` を scripts に追加する

> How-to は「コマンド暗記」より  
> **“ここを見れば最新版”** を固定してリンクする方がズレません。

---

## 2. 最短ルート：まずは「CIと同じ3つ」
PR前に最低限これを通します（CIでも必ず走る）。

```bash
pnpm install --frozen-lockfile
pnpm lint
pnpm test
````

（型チェックを運用している場合）

```bash
pnpm type-check
```

> もし「まだテストが1本も無い」状態なら  
> まずは **最低限のテストを1本追加**するのが本筋。  
> どうしても今は難しい場合だけ、**一時措置として**  
> `pnpm test -- --passWithNoTests` を使う（CIも同様）。  
> ※ テストが追加されたら **必ず元に戻す**

### コマンドの意味（初心者向け）

* `pnpm install --frozen-lockfile`

  * 依存関係（ライブラリ）を入れる
  * `--frozen-lockfile` は「lockfileと矛盾したら失敗する」安全モード
    → CIと同じ状態になりやすい
* `pnpm lint`

  * ESLintで「書き方のルール違反」を見つける（早い・安い）
* `pnpm type-check`（scriptsにある場合）

  * TypeScriptの型チェック（実行しなくてもバグを見つける）
* `pnpm test`

  * Jestで自動テスト（仕様の合否を機械が判定）

---

## 3. E2E（必要なときだけ）：Maestro smoke

DotChain には E2E の入口として `test:e2e` が用意されています。

```bash
pnpm test:e2e
```

### 3.1 何が起きる？

* Maestro が `maestro/flows/smoke.yml` を実行
* アプリを起動して、最低限の操作ができるかを確認する（スモークテスト）

### 3.1.1 まず最初に直すべきこと（重要）
* `maestro/flows/smoke.yml` の `appId: "CHANGE_ME_APP_ID"` を **実アプリのID**に書き換える
* E2Eで使う `testID` が実装側にあるか確認する（無ければ追加）

### 3.2 ここが注意（詰まりやすい）

* 端末/エミュレータが必要
* 初回は Maestro のインストールが必要になることがある
* CIでは条件付きで走る設定になっている場合がある（SecretsやAPKの有無）

---

## 4. CIが落ちたときの「調査の順番」

落ちたら、焦らずこの順番で見ると速いです。

### 4.1 まず GitHub Actions のログを見る

* どのジョブが落ちた？（Lint / Type Check / Test / E2E）
* どのステップで落ちた？

### 4.2 ローカルで同じコマンドを叩いて再現

CIが落ちたステップだけを、まずローカルで叩く：

* Lintで落ちた → `pnpm lint`
* 型で落ちた → `pnpm type-check`（運用している場合）
* Jestで落ちた → `pnpm test`
* E2Eで落ちた → `pnpm test:e2e`

---

## 5. 典型パターン別：直し方（超実用）

### 5.1 Lint（eslint）で落ちる

* よくある原因

  * unused 変数
  * import順
  * hooksの依存配列
* 対処

  1. エラー行を見る
  2. ルールに合わせて直す
  3. もう一回 `pnpm lint`

---

### 5.2 type-check（tsc）で落ちる（運用している場合）

* よくある原因

  * 型が合ってない
  * null/undefined を考慮してない
  * import先が間違ってる
* 対処

 1. 最初のエラーから直す（連鎖するから）
 2. 直したら `pnpm type-check`（運用している場合）

---

### 5.3 Jest（pnpm test）で落ちる

* よくある原因

  * 期待値が変わった（仕様変更）
  * モック不足（依存が多い）
  * 非同期処理の待ち不足
* 対処

  1. 失敗しているテスト名を見る
  2. “何が期待で、実際は何だったか” を読む
  3. 仕様が正しいならテストを直す / 仕様が違うならコードを直す
  4. `pnpm test` 再実行

---

## 6. 「テスト仕様を実行できる仕様に近づける」と整合が保たれる理由（超かみ砕き）

※ここだけ少し Explanation っぽいけど、理解に必須なので最小限で。

### 6.1 たとえ話

* 仕様書が「ノート」だと、書き忘れる（更新漏れする）
* テストが「自動採点機」だと、間違うと必ず赤点（CIが落ちる）

つまり、

* 仕様（合格条件）をテストにすると
  **守れてない瞬間に“必ず止まる”**
  → “勝手に整合が保たれる” の正体はこれです

### 6.2 実務での形

* Issue の受け入れ条件（Acceptance Criteria）
  ↓
* Jest / Maestro のテスト
  ↓
* CI が自動で実行して合否を判定
  ↓
* 落ちたらマージできない（ブランチ保護）

---

## 7. 新しいテストを追加するときの最小ルール

* バグ修正：**再発防止のテスト** を1つ足す
* 機能追加：**受け入れ条件がチェックできるテスト** を足す
* E2E：壊れやすいので「本当に価値があるところ」だけ（スモークから）

---

## 8. 最後のチェックリスト（PR前）

* [ ] `pnpm lint` OK
* [ ] `pnpm type-check` OK（運用している場合）
* [ ] `pnpm test` OK
* [ ] 必要なら `pnpm test:e2e` OK
* [ ] 受け入れ条件が満たされた（PR本文に証拠を書く）
