# 4_実装ルール.md（DotChain）
目的：DotChainの実装を「迷わず」「ブレずに」「テストで守れる」ようにする

---

## 0. この文書の使い方（超重要）
この文書は「コードの交通ルール」です。  
開発の流れ（Issue→ブランチ→PR→CI→マージ）は `docs/how-to/whole_workflow.md` を見てください。

### 0.1 いつ読む？
- これから新しく機能を作るとき（迷子防止）
- 既存コードを直すとき（置き場所・ルール確認）
- PRレビューするとき（ルール違反の発見）
- Codex/AIに「実装方針」を渡すとき（参照点）

### 0.2 “正（ソースオブトゥルース）”はどこ？
ズレやすいものは、この文書に固定で書かない。代わりに「正」を決めます。

- **依存関係・スクリプト（コマンド名）**：`package.json` が正
- **CIで実際に走る手順**：`.github/workflows/*` が正
- **前提/制約（変わりにくい約束）**：`docs/reference/constraints.md` が正
- **なぜそうしたか（理由・代案・結論）**：`docs/adr/ADR-*.md` が正
- **合否（受け入れ条件）**：自動テスト（Jest / Maestro）が正
- **UIの最終図面**：Figma が正（URLを docs に置く）

> ここがブレると仕様書が死ぬので、この「正の置き場」を絶対に守る。

---

## 1. リポジトリ構造（置き場所ルール）
※フォルダ構造は今ある形を前提にする。新規追加もこの考え方に沿う。

- `app/`：画面（Expo Router のルート）
  - 画面は “薄く” 保つ（表示＋イベント結線）
  - 重いロジックは `src/features` / `src/stores` へ

- `src/features/`：機能単位の実装（例：habit）
  - UI部品、ユースケース、ドメインロジックの中心
  - 「この機能だけの関心」はここに閉じる

- `src/stores/`：状態管理（Zustand）
  - 画面をまたぐ状態、永続化、同期、購読状態など

- `src/core/`：横断関心（全体に効くもの）
  - i18n、日付キー、通知、設定、ログ（将来）など

- `src/services/`：外部I/O（API / 課金 / 広告 / OS連携など）
  - 直接UIから叩かない（テスト可能性を上げるため）

- `src/db/`：DBアクセス（SQLite）
  - SQL/テーブル/マイグレーション/CRUD

- `maestro/`：E2Eテスト（フロー）
- `docs/`：仕様・運用（docs-as-code）
- `.github/`：テンプレ、CODEOWNERS、CI設定

---

## 2. 命名ルール（迷子を減らす）
### 2.1 ファイル/フォルダ
- Reactコンポーネント：`PascalCase.tsx`（例：`HabitCard.tsx`）
- それ以外（関数/ユーティリティ）：`camelCase.ts` または `kebab-case.ts`
- hooks：`useXxx.ts`
- テスト：`*.test.ts` / `*.test.tsx`

### 2.2 変数/関数
- 変数・関数：`camelCase`
- 型：`PascalCase`
- 真偽値：`isXxx / hasXxx / canXxx`

### 2.3 import順
1. 外部ライブラリ
2. 内部（`@/`）
3. 相対パス（`./`）

---

## 3. TypeScriptルール（バグの芽を潰す）
- `any` は原則禁止（どうしてもなら理由をコメント）
- 型は「後付け」じゃなく「設計」に使う  
  例：`TranslationKey` を使って “存在しない翻訳キー” をコンパイルで落とす
- 例外（throw）を乱発しない  
  UIに出す必要がある失敗は、戻り値/ストアの `error` で扱う

---

## 4. UI実装ルール（UI改修地獄を減らす）
あなたの反省点「仕様書だけUI→改修多発」を潰すためのルール。

### 4.1 UIの正はFigma
- 画面・コンポーネント・余白・状態（通常/空/エラー/ロード）は **Figmaに集約**
- docsには **Figmaリンク** と **画面一覧（索引）** だけ置く（ズレにくい）

### 4.2 画面（app/）は薄く
- 画面の責務：表示・入力・押下イベント
- ロジック：store / feature / service へ
- “画面ファイルが肥大化”したら分割する

### 4.3 Tamagui利用ルール
- 直値（ハードコード）を増やしすぎない  
  → トークン/テーマを優先（後から全体変更しやすい）
- 同じUIが2回出たら共通化候補（`src/ui` へ）

---

## 5. 状態管理（Zustand）ルール
### 5.1 storeの責務
- 画面から触る「状態」と「操作」をまとめる
- DB/外部I/Oは store から service/db を呼ぶ（UI直叩き禁止）

### 5.2 エラーハンドリング
- UIに見せる失敗：storeに `error` を持たせる
- `error` は翻訳キー（またはユーザー向け文言）で扱う
- 失敗したら「何が起きたか」「どう復帰するか」がUIで分かること

### 5.3 永続化（persist）を使うとき
- 全部保存しない（肥大化・事故の元）
- “保存が必要なものだけ” partialize する
- 保存先が変わる場合はADRを書く（データ破壊が起きるため）

---

## 6. DB（SQLite）ルール
- SQL/CRUDは `src/db` に集約
- store/featureは「SQL文字列を直書きしない」
- テーブル追加・変更は必ず
  1) マイグレーション（または初期化処理）  
  2) 既存データがある場合の互換  
  3) テスト（少なくともJestで最低限）  
  をセットで考える

---

## 7. i18nルール（翻訳事故を潰す）
- 画面やコンポーネントで文字を直書きしない（例外：デバッグ）
- 翻訳キーは `TranslationKey` 型で管理する（存在しないキーを防ぐ）
- 言語コードは **`nl`（オランダ語）を正** とする
- “文章を組み立てる”場合は、翻訳側で表現できる形を優先
  （コード側で単語を足し引きして文章を作ると、多言語で破綻しやすい）

---

## 8. 外部SDK導入ルール（購読/広告/分析など）
外部SDKは「あとから地獄」になりやすいので手順を固定する。

### 8.1 入れる前に必ず決める（constraints/ADR）
- 何のために入れる？（価値）
- 代案は？なぜ捨てる？
- データ（個人情報/課金/広告ID）に触れるか？
- OSごとの設定が必要か？

→ 結論と理由は **ADR** に残す（蒸し返し防止）

### 8.2 実装の置き場
- `src/services/` にラッパーを作る（UI直結しない）
- “本番だけON” などの切り替えは設定で吸収（ハードコードしない）

### 8.3 AdMob（次回マスト）の前提
- 広告は「表示箇所」「頻度」「子供向け/同意」「ストア審査」を強く意識する
- 実装開始前にADRを書いて、審査事故を減らす

---

## 9. テストルール（“合否＝テスト”に寄せる）
「仕様がテストに寄ると整合が保たれる」の意味はこれ：

- 仕様（合格条件）がテストで表現されている  
  → コードを変える  
  → テストが落ちる  
  → 直さないとマージできない  
  だから “勝手にズレが見つかる”

### 9.1 Jest（ユニット/ロジック）
- storeのロジック、日付キー、変換、境界条件を重点的に
- “壊れたら困るもの”からテストを増やす

### 9.2 Maestro（E2E/受け入れ）
- 代表フロー（smoke）を最優先
- 1フローは短く。落ちたら原因がすぐ分かる粒度にする
- “仕様（受け入れ条件）” をそのままフロー名にする  
  例：`maestro/flows/smoke.yml` = 最低限の動作確認

---

## 10. コマンド早見表（意味の説明）
※正確なコマンド名の一覧は `package.json` の `scripts` が正

### 10.1 依存関係
- `pnpm install`
  - 必要なライブラリを入れる
- CIでよくある `--frozen-lockfile`
  - ロックファイルを書き換えない（勝手にバージョンが変わる事故防止）

### 10.2 開発
- `pnpm dev` / `pnpm start`
  - 開発サーバー起動（QRやエミュレータ連携の入口）
- `pnpm android`
  - Android用にネイティブ実行（端末/エミュレータへ）
- `pnpm ios`
  - iOS用にネイティブ実行（Mac環境が必要になりがち）
- `pnpm prebuild`
  - ネイティブプロジェクト生成（触る前に影響範囲を理解する）

### 10.3 品質チェック
- `pnpm lint`
  - ESLintで「怪しい書き方」を検出
- `pnpm type-check`（scriptsにある場合）
  - TypeScriptの型チェック（ビルド前に壊れ方を見つける）
- `pnpm test`
  - Jestテストを実行（仕様の“合否”）
- `pnpm test:e2e`
  - Maestroの代表フロー（最低限の受け入れ確認）

### 10.4 ビルド（Android）
- `pnpm build:android`
  - Androidのリリース用ビルド（配布物の生成）
  - 失敗したらGradle/署名/環境差分を疑う

---

## 11. DoD（完了の定義：実装側）
最低限これが揃って“完了”とする（PRテンプレのチェックと一致させる）

- [ ] 変更の目的が説明できる（なぜ）
- [ ] 受け入れ条件が書ける（合否）
- [ ] `lint` `test`（必要なら type-check / e2e）が通る
- [ ] 仕様に関わる変更なら docs 更新（ただし“正”は守る）
- [ ] 意思決定が発生したなら ADR を追加/更新

---

## 12. リスクアセスメント（この文書が死なないために）
### 12.1 ありがちな事故
1) ルールが増えすぎて読まれない  
2) 実際のコードとズレる  
3) ルール違反がレビューで見逃される  
4) “なんとなく”の例外が増えて崩壊  
5) AI/Codexが誤読して変なPRを量産

### 12.2 なぜなぜ分析（5回）
Q：なぜ実装ルールが守られず形骸化する？

- なぜ1：守らなくてもマージできるから  
- なぜ2：CIやテンプレで強制されていないから  
- なぜ3：強制する仕組みを作るコストが後回しになるから  
- なぜ4：短期の“進捗”が優先され、品質の負債が見えにくいから  
- なぜ5：ルールが「日常のチェック」に組み込まれていないから（習慣にならない）

→ 根っこ：**“守ると得する/守らないと損する” の構造がない**

### 12.3 恒久策（仕組みで勝たせる）
- CIで必須：lint / test（必要なら type-check / e2e）
- ブランチ保護：CIが落ちたらマージ不可、レビュー必須
- CODEOWNERS：重要ファイル（docs/adr、constraints、課金、セキュリティ）にオーナーを付ける
- PRテンプレ：チェックが埋まらないとマージしない運用
- ルールは増やしすぎない：本文は短く、詳細はリンク/ADR/テストへ

---

## 13. 参考リンク（一次情報）
- GitHub Branch protection（保護ブランチ）：https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches
- GitHub CODEOWNERS：https://docs.github.com （CODEOWNERS / About code owners を参照）
- Issue Forms（YAML）：https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests/syntax-for-issue-forms
- Conventional Commits：https://www.conventionalcommits.org/
- Diátaxis：https://diataxis.fr/
- Jest CLI：https://jestjs.io/docs/cli
- Maestro：https://docs.maestro.dev/
