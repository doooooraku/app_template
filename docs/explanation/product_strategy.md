# プロダクト戦略（DotChain）
> Diátaxis: Explanation（Why / 価値・スコープの境界・判断基準）

---

## 0. この文書の役割（最重要）
この「プロダクト戦略」は、DotChainの**価値**と**スコープ境界**と**判断基準**を固定するための文書です。  
つまり、実装中に迷ったときに「戻ってくる地図」です。

### 0-1. 読むと分かること
- DotChainは**誰のための**何のアプリか
- v1.x（当面）で「**やること / やらないこと**」の境界
- 仕様が増えた時に「それは今やるべき？」を決める判断基準
- 収益の柱（今 / 次）と、やってはいけない収益設計
- 仕様書が形骸化しないための**分離ルール**（本文/ADR/テスト/constraints）

### 0-2. この文書に「書くこと / 書かないこと」
**書くこと（この文書が守る領域）**
- 変わりにくい「不変条件（Principles）」
- 価値（Value Proposition）と対象ユーザー
- スコープ境界（Non-goals含む）
- 成功指標（KPIの定義と優先）
- 収益モデルの骨格（今/次）
- 重大なリスクと恒久策（運用設計を含む）

**書かないこと（ズレやすいので別へ）**
- バージョン番号、依存関係の細部 → **正はコード（package.json / lock / CI）**
- 実装手順やコマンド一覧 → **docs/how-to/**（運用手順）
- 画面ごとのUIの細部 → **Figma（正）＋必要ならReferenceに最小限**
- 「なぜそう決めたか」の議論の経緯 → **docs/adr/**（意思決定ログ）
- 合否判定の条件 → **テスト（自動）＋テスト仕様書**

---

## 1. DotChainとは（1行で）
**「1タップで“続けた証拠”を増やし、チェーンとして見える化する習慣トラッカー」**

---

## 2. 価値（ユーザーに起きる良い変化）
### 2-1. 価値のコア
DotChainのコア価値は「入力の軽さ」ではなく、  
**“続けた証拠が積み上がる気持ちよさ（視覚的な達成感）”**です。

### 2-2. ユーザーの状態変化（Before→After）
- Before：やる気はあるが、記録が面倒で続かない。続いた実感が薄い。
- After：1タップで記録でき、チェーンが伸びて「今日もやった」が残る。やめたくなくなる。

---

## 3. 対象ユーザー（誰のため？）
### 3-1. メインターゲット
- 20〜39歳：勉強・筋トレ・読書・語学など「自己投資習慣」を続けたい層
- 16〜24歳：デザイン/UIの気持ちよさを重視し、無料で試して課金も検討する層

### 3-2. 対象外（v1.xでは狙わない）
- 友達と競う・共有する（ランキング/フレンド/グループ）
- 複雑なタスク管理（プロジェクト管理/カンバン/ガント）
- 体重・カロリー等のヘルスデータ連携の本格運用

---

## 4. 体験設計の原則（不変条件）
### 原則P1：入力は極限まで軽く
- v1.xでは「やった/やってない」の2値が基本（必要最小限）
- 文字入力は増やさない（増やすならADRで判断してから）

### 原則P2：ホームは“今日の1タップ”に全集中
- 「今日やる」→「タップ」→「チェーンが増える」を最短距離にする
- 画面を増やして迷子にしない

### 原則P3：見た目は価値（UIは機能）
- DotChainはUIの気持ちよさ自体が継続率に直結する
- 次回以降、UIの正は **Figma**（仕様書は補助）

### 原則P4：無料でも試せるが、自然に課金導線へ
- 無料版は「使える」範囲を確保する（ただし制限は明確に）
- 課金導線は“邪魔”ではなく“納得”で作る

---

## 5. スコープ境界（v1.xの線引き）
### 5-1. v1.xで必ず守るコア
- 習慣の追加/編集/削除
- 1タップ記録
- チェーン（カレンダー可視化）
- Free/Proの制限分岐（習慣数・テーマ等）
- サブスクリプション（購入/復元）
- 多言語（18言語）
- テーマ切替（Free/Pro差分）

### 5-2. v1.xで「やらない」こと（明確に捨てる）
- ソーシャル（共有/ランキング/友達）
- RTL対応（右→左言語）
- ウィジェット（ホームウィジェット）
- “複雑な分析”グラフ重視（DotChainは視覚的チェーンが主役）

---

## 6. 収益モデル（今 / 次）
### 6-1. 収益の柱（ロードマップ）
**今（現行）**：サブスクリプション（Pro）を主軸  
- Pro価値：習慣無制限、テーマ解放、広告なし（※広告は次フェーズ導入予定でも「広告なし」を価値として固定）

**次（必ず入れる）**：AdMob（Free向けバナー）  
- Freeの体験を壊さない範囲の“最小広告”
- 全画面/動画の乱発はしない（継続率を壊すから）

> 注：AdMob導入は「次回からマスト」。ただし導入の仕方（表示箇所・頻度・計測）はADRで決定する。

### 6-2. 価格の考え方（方針）
- 価格は将来変更し得る（市場/ストア/地域で揺れる）
- ただし「年額は月額よりお得に見える」構造は維持する
- 価格の具体値はこの文書に固定しない（ズレやすいので）

---

## 7. 成功指標（KPI）と優先順位
### 7-1. 北極星（North Star）
**「1週間で“達成タップ”が継続して発生しているユーザー数」**  
（＝続ける体験が成立しているかを見る）

### 7-2. 重要KPI（優先順）
1) 継続率（D1/D7/D30）  
2) 週あたりの達成タップ回数（体験の密度）  
3) 無料→Pro転換率  
4) 解約率（チャーン）  
5) ストア評価（☆、レビュー内容）

---

## 8. 多言語（18言語）方針（不変条件）
### 8-1. 対応言語コード（正）
- en, ja, fr, es, de, it, pt, ru, ko, hi, id, th, vi, tr, **nl**, sv, zhHans, zhHant
- **nl（オランダ語）が正**（これを固定）

### 8-2. 多言語運用の約束
- 文言の追加/変更は「キー追加→全言語に最低限の値→不足はIssue化」
- 画面崩れは「仕様」ではなく「バグ」扱い（優先度高）

---

## 9. 仕様が生き続けるための“分離”設計（超重要）
### 9-1. 3点分離（本文 / ADR / テスト）
- **本文（この文書）**：Why（価値・境界・判断基準）
- **ADR**：Whyの“議論の結論と理由”（蒸し返し防止）
- **テスト**：合否（受け入れ条件）を自動で判定（整合が保たれる）

### 9-2. constraints（前提/制約）に寄せるルール
「決まっていること（前提/制約）」は **docs/reference/constraints.md** に集約する。  
この戦略書には “制約の全文” を持たない（リンクする）。

---

## 10. 主要リスク（リスクアセスメント）
> 方針：リスクは「気合」ではなく「仕組み」で潰す（恒久策を持つ）

### 10-1. リスク一覧（例）
- R1：仕様書が更新されず形骸化して、実装と乖離する
- R2：AdMob導入でポリシー違反 → 配信停止 / 審査落ち
- R3：課金/復元の不具合 → 返金/低評価/信頼失墜
- R4：多言語の抜け漏れ → UI崩れ/意味不明/低評価
- R5：UIがFigmaとズレる → 改修地獄で工数爆発

### 10-2. なぜなぜ分析（5回以上）＋恒久策

#### R1：仕様書が形骸化する（5 Whys）
1. なぜ形骸化する？  
   → 実装が進むと、仕様書更新が後回しになるから。
2. なぜ後回しになる？  
   → 更新対象が広すぎて「どこを直すか」判断が重いから。
3. なぜ判断が重い？  
   → 仕様書が“コードと同じ細かさ”まで持ってしまっているから。
4. なぜ細かさを持ってしまう？  
   → 「全部書けば安心」と思い、ズレやすい情報まで固定しているから。
5. なぜズレやすい情報を固定する？  
   → “正（ソース・オブ・トゥルース）”の置き場所が決まっていないから。
6. なぜ正の置き場所が決まっていない？  
   → docs-as-codeの運用（DoD/テンプレ/CI）が未整備で、更新が強制されないから。

**恒久策（仕組み）**
- 文書を分離する：本文はWhy、理由はADR、合否はテスト、前提はconstraints
- DoD（完了条件）に「関連文書更新」を入れる（PRテンプレで強制）
- 変更はPRでしか入れない（直push禁止＋ブランチ保護）
- 仕様変更は「Issue→ADR（必要なら）→実装→テスト→docs更新」の順で運用

#### R2：AdMobで事故る（5 Whys）
1. なぜ事故る？  
   → ポリシー違反や不適切配置で広告配信が止まるから。
2. なぜ違反する？  
   → “どの画面で/どの形式で/どの頻度で” のルールが曖昧だから。
3. なぜ曖昧？  
   → 実装優先で、ポリシー確認と設計が後回しになるから。
4. なぜ後回し？  
   → リリース前チェックが「人の記憶」に依存しているから。
5. なぜ記憶依存？  
   → 事前にチェックリストとテスト（手順）を文書化していないから。

**恒久策（仕組み）**
- AdMob導入はADRを必須にする（配置・形式・計測・回避事項を固定）
- リリース手順（docs/how-to/android_ビルド手順.md / docs/how-to/ios_ビルド手順.md）に「広告ポリシー確認」を組み込む
- Free/Proの広告分岐はE2E/回帰テストで毎回確認する

---

## 11. 関連文書（DotChainの“地図”）
- docs/reference/constraints.md（前提・制約の一枚岩）
- docs/adr/（意思決定ログ：なぜそうしたか）
- docs/reference/glossary.md（用語集：同じ言葉を同じ意味で使う）
- docs/how-to/whole_workflow.md（開発運用：Issue→Branch→PR→CI→Merge）
- docs/how-to/android_ビルド手順.md（Androidリリース運用）
- docs/how-to/ios_ビルド手順.md（iOSリリース運用）
- 受け入れ条件：テスト（Jest / E2E）とテスト仕様書

---

## 12. 外部一次情報リンク（“正”の参照先）
※リンクはズレる可能性があるので、必要に応じて見直す。
```txt
# Diátaxis（公式）
https://diataxis.fr/

# Apple（App Store Review Guidelines）
https://developer.apple.com/app-store/review/guidelines/

# Google AdMob（ポリシー/制限）
https://transparency.google/intl/en/our-policies/product-terms/google-admob
https://support.google.com/admob/answer/6128543?hl=en

# GitHub Docs（CODEOWNERS）
https://docs.github.com/articles/about-code-owners

# ADR（原典の代表：Documenting Architecture Decisions）
https://www.cognitect.com/blog/2011/11/15/documenting-architecture-decisions
https://adr.github.io/adr-templates/
